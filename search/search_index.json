{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Willkommen bei der AV DIMAG Entwicklergruppe","text":"<p> \u00a0 Die Seite ist im Aufbau und daher noch nicht vollst\u00e4ndig!</p> <p>Um gemeinsam am selben Strang zu ziehen und dies in dieselbe Richtung, ist es wichtig, dass wir ein paar Spielregeln definieren betreffend Code schreiben, Git- und Release Prozess, Arbeitsaufteilung, sowie dem Protokollieren von Testcases.</p>"},{"location":"agile/","title":"Wie sieht die Agile Entwicklung aus?","text":"<p> \u00a0 Das Dokument ist im Aufbau und daher noch nicht vollst\u00e4ndig!</p> <p>Wir wollen die Entwicklung und die Prozesse m\u00f6glichst einfach halten. Im Grundgedanke basiert unsere Softwareentwicklung auf Scrum, jedoch nicht bis ins Detail ausgepr\u00e4gt. Ein Sprint dauert jeweils zwei Wochen (Do - Mi). Jeden zweiten Mittwoch trifft sich das Tech-Board zum Sprint-Review und zur Planung. Folgende Traktanden geben den Fahrplan der Sitzung vor:</p> <ol> <li>Review: Die Entwickler zeigen den aktuellen Stand der Applikation (gem. aktuellem Sprintplan)</li> <li>Meldungen der Vertreter aus der Fachgruppe</li> <li>Meldungen aus dem Fach-Board (gem. Diskussion)</li> <li>Planung des n\u00e4chsten Sprints anhand von Diskussionsbeitr\u00e4gen und deren Priorisierung</li> </ol>"},{"location":"agile/#releases","title":"Releases","text":"<p>Die Releases erfolgen halbautomatisch gem\u00e4ss Anleitung. Geplant werden sie anhander der Milestones-Liste.</p>"},{"location":"code/","title":"Wie schreiben wir Code?","text":"<p> \u00a0 Das Dokument ist im Aufbau und daher noch nicht vollst\u00e4ndig!</p> <p>Die meisten Spielregeln betreffend Schreibweisen im Code sind bereits in <code>.editorconfig</code> und in <code>.eslintrc.js</code> im jeweiligen Repository definiert. Dennoch tragen wir hier die paar Regeln zusammen, um einen einheitlich aussehenden Code zu erhalten.</p>"},{"location":"code/#sprache","title":"Sprache","text":"<p>Bezeichnung von Variablen und Funktionen, aber auch Kommentare m\u00fcssen in Englisch geschrieben sein. Variable- und Funktionsbezeichnungen sollten kurz, aber noch immer verst\u00e4ndlich benannt werden; nicht gel\u00e4ufige Abk\u00fcrzungen sollten vermieden werden.</p> <p>Commit Messages werden ebenfalls in Englisch geschrieben.</p>"},{"location":"code/#format","title":"Format","text":""},{"location":"code/#einrucken","title":"Einr\u00fccken","text":"<p>Generell arbeiten wir mit Leerschlag anstelle von Tabs. Zwei Leerschl\u00e4ge bei allen Dokumenten mit Ausnahme von Typescript; hier helfen 4 Leerschl\u00e4ge zur besseren Lesbarkeit.</p>"},{"location":"code/#kommentare","title":"Kommentare","text":"<p>Jede Funktion muss mit einem Kommentar im Stil von TSDoc versehen werden. Sp\u00e4ter k\u00f6nnen wir aus diesen Kommentaren die Dokumentation generieren. Es hilft aber auch den Code zu verstehen und ist hilfreich beim Wiederverwenden einer Funktion.</p> <pre><code>/**\n * Adds two numbers together.  \n * @example { add two positive numbers }\n * add(1,1) // prints \"2\"\n * \n * @example { add two negative numbers }\n * add(-1,-1) // prints \"-2\"\n */ \nexport const add = (x: number, y: number): number =&gt; x + y;\n</code></pre>"},{"location":"git/","title":"Wie sehen die Abl\u00e4ufe auf Github aus?","text":"<p> \u00a0 Das Dokument ist im Aufbau und daher noch nicht vollst\u00e4ndig!</p> <p>Unsere Software steht unter der Git Versions Kontrolle. Dazu verwenden wir GitHub. Hier wird haupts\u00e4chlich ein Ingest-Vorbereitungstool f\u00fcr den eCH-0160 Standard entwickelt:</p> <p></p> <p>Das Vorgehen bei der Entwicklung ist stets dasselbe. Wir folgen den Empfehlungen von GitHub flow:</p> <ol> <li>Neuen Branch von \"main\" erstellen.</li> <li>Commits schreiben.</li> <li>Pull Request \u00f6ffnen.</li> <li>Code Review durchf\u00fchren.</li> <li>Branch in <code>main</code> mergen</li> </ol>"},{"location":"git/#sprache","title":"Sprache","text":"<p>Ich schlage vor, dass die Benennung des Branchs und der Commits in Englisch geschrieben werden.</p>"},{"location":"git/#branch","title":"Branch","text":"<p>Branch werden anhand von Issues erstellt. Nachdem jemandem ein Issue zugewiesen wurde, kann \u00fcber den Link <code>Create a branch</code> im jeweiligen Issue schnell ein Branch erstellt und darin gearbeitet werden. Die Benennung des Branchs erfolgt aus dem Titel des Issues, kann aber auch bereits \u00e4hnlich der sp\u00e4teren PR-Commit-Message (s. commits) erfolgen.</p> <p>Ich kann mir ein System vorstellen, das mit dem \u00c4nderungstyp (feat, fix, chore, etc.) beginnt und durch einen Schr\u00e4gstrich <code>/</code> von der restlichen Bezeichnung getrennt wird. Danach folgt der Bereich (scope) und eine kurzer Betreff (subject); alles in kebab-case mit Bindestrich \"-\".</p> <p>Der Issue #24 ist ein Feature Request und hat den folgenden Titel: <code>feat [workflow]: Startseite mit Ladezone</code></p> <p>Der Branch w\u00fcrde dann wie folgt aussehen: <code>feat/workflow-landingpage</code></p> <p>Und, um es vorwegzunehmen, der sp\u00e4tere Titel des PRs sollte wie eine Commit Message geschrieben sein. In diesem Beispiel lautet dieser dann: <code>feat(workflow): Landingpage with drop zone</code></p> <p> Hier kommt sp\u00e4ter auch die Thematik Codespace hinzu. </p>"},{"location":"git/#commits","title":"Commits","text":"<p>Um eine einheitliche Lesbarkeit zu garantieren, insbesondere im Zusammenhang mit den Releases, den Versionen (s. SemVer) und den Changelogs, m\u00fcssen die Commit-Nachrichten strikten Regeln folgen. Wir halten uns an Conventional Commit messages, die folgendes Format vorgeben:</p>"},{"location":"git/#format-eines-commits","title":"Format eines Commits","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n</code></pre>"},{"location":"git/#typ-type","title":"Typ (type)","text":"<p>Der Typ muss einer der Folgenden sein:</p> <ul> <li>fix: bei Bug fixes. Ein solcher Commit \u00e4ndert die Version auf Ebene patch</li> <li>feat: bei neuen Features. Ein solcher Commit \u00e4ndert die Version auf Ebene minor.</li> <li>refactor: wenn der Code oder die Struktur aufger\u00e4umt/reorganisert wird. Ein solcher Commit \u00e4ndert die Version auf Ebene patch.</li> <li>feat!, fix!, refactor!, etc.: Im Falle eines Breaking Changes wird das Ausrufzeichen verwendet. Ein solcher Commit \u00e4ndert die Version auf Ebene major.    Es ist wichtig, dass das Ausrufezeichen vor dem Doppelpunkt steht; z.Bsp. <code>feat!: &lt;subject&gt;</code> oder <code>feat(workflow)!: &lt;subject&gt;</code></li> <li>docs: \u00c4nderungen an der Dokumentation (keine \u00c4nderung am produktiven Code).</li> <li>chore: Wartungsarbeiten bspw. Github Actions o.\u00e4. (keine \u00c4nderung am produktiven Code).</li> <li>style: Design Updates (keine \u00c4nderung am produktiven Code).</li> <li>test: Alles rund um Tests; auch im Fall von Test-Refactoring (keine \u00c4nderung am produktiven Code).</li> </ul> <p>Die ersten vier Punkte dieser Liste haben einen Einfluss auf die Versionsnummer und werden in den Release Notes aufgef\u00fchrt.</p>"},{"location":"git/#bereich-scope-optional","title":"Bereich (scope; optional)","text":"<p>Die Zuordnung zu einem Bereich (scope) ist optional. Es ist aber sinnvoll, wenn dieser auch gesetzt wird.</p> <p> Wir werden noch eine entsprechende Themenliste ausarbeiten. </p> <p>Bisherige Scopes:</p> <ul> <li>workflow</li> <li>xml-converter</li> <li>ci/cd</li> </ul>"},{"location":"git/#betreff-subject","title":"Betreff (subject)","text":"<p>Der Betreff (subject) beinhaltet eine knappe Beschreibung der \u00c4nderung:</p> <ul> <li>man verwendet den englischen Imperativ: \"change\" nicht \"changed\" oder \"changes\"</li> <li>Der erste Buchstabe wird klein geschrieben</li> <li>Am Ende steht kein Punkt</li> </ul>"},{"location":"git/#pull-request","title":"Pull Request","text":""},{"location":"git/#titel-und-beschreibung","title":"Titel und Beschreibung","text":"<p>Ein Pull Request entspricht in der Regel mindestens einem Issue oder einer User Story. Da wir f\u00fcr die Versionierung und die Releases die release-please-action verwenden, ist es sehr wichtig, dass der PR Titel korrekt geschrieben wird. Der Titel wird f\u00fcr die Commit Message des Merges \u00fcbernommen. Deshalb muss er, wie unter Commits definiert, entsprechend geschrieben werden; s. auch das Beispiel unter Branch. Wird der Titel falsch geschrieben, wird der PR sp\u00e4ter nicht im Changelog oder in den Release Notes aufgelistet!</p> <p>In der Beschreibung wird immer der zugeh\u00f6rige Issue verlinkt. Dazu wird eines der Github-Schl\u00fcsselw\u00f6rter <code>resolves</code>, <code>closes</code> etc. gefolgt von der Issue Nummer.</p> <pre><code>resolves #42\n</code></pre> <p>In diesem Beispiel wird der Issue Nr. 42 mit dem PR beidseitig verkn\u00fcpft und nach dem Merge ebenfalls automatisch geschlossen.</p>"},{"location":"git/#label-optional","title":"Label (optional)","text":"<p>Das Setzen eines Labels ist optional, ist aber sicher hilfreich beim Sortieren und Auffinden bestimmter Pull Requests. Im Release Prozess hat es jedenfalls keinen Einfluss mehr.</p> <ul> <li>breaking: Breaking Changes.</li> <li>enhancement: Neue Features.</li> <li>bug: Bug fixes.</li> <li>styling Style resp. Design Updates (keine \u00c4nderung am produktiven Code).</li> <li>documentation: \u00c4nderungen an der Dokumentation.</li> <li>testing: Alles mit Tests (keine \u00c4nderung am produktiven Code).</li> <li>refactor: Simples \u00dcberarbeiten des Codes.</li> <li>chore: Wartungsarbeiten, insbesondere Github betreffend (CI/CD) (keine \u00c4nderung am produktiven Code).</li> <li>dependencies: Updates von Paketversionen.</li> </ul>"},{"location":"git/#entwurf","title":"Entwurf","text":"<p>Bitte konvertiere den Pull Request zu einem Entwurf so lange dieser nicht parat f\u00fcr den Review ist. Sobald dies der Fall ist, wird der Entwurfsstatus wieder entfernt, klicke dazu auf die entsprechende Schaltf\u00e4che: \"Ready for review\".</p>"},{"location":"git/#geschutzter-branch","title":"Gesch\u00fctzter Branch","text":"<p>Der Hauptbranch <code>main</code> in jedem Repository ist gesch\u00fctzt. Folgende Regeln m\u00fcssen vor einem Merge eingehalten werden:</p> <ul> <li>Mindestens ein Code Review wird ben\u00f6tigt</li> <li>Status Checks:</li> <li>Branch muss von Seiten <code>main</code> aktualisiert sein</li> <li>Test- und Build-Prozess in den Github Actions (CI/CD) m\u00fcssen erfolgreich sein</li> </ul> <p>Nach dem Mergen wird der entsprechende Branch automatisch gel\u00f6scht.</p>"},{"location":"git/#code-review","title":"Code Review","text":"<ul> <li>Ein Reviewers soll neben dem Code, der Funktionalit\u00e4t auch die PR Titel Einstellungen pr\u00fcfen, damit Release-Please einwandfrei funktioniert.</li> </ul>"},{"location":"git/#github-actions-cicd","title":"GitHub Actions (CI/CD)","text":"<p>Wir benutzen GitHub Actions, um automatisch Tests, Releases und das Deployment durchzuf\u00fchren.</p>"},{"location":"git/#tests","title":"Tests","text":"<p>Mit jedem Push nach GitHub werden \"Builds\" und Tests ausgef\u00fchrt. Diese m\u00fcssen erfolgreich durchlaufen, bevor neuer Code in den Hauptbranch gemergt werden kann (s. Gesch\u00fctzter Branch).</p>"},{"location":"git/#release-vorbereiten","title":"Release vorbereiten","text":"<p>Wir benutzen release-please-action, um einen Release vorzubereiten. Dieses GH Action Skript erstellt automatisch die <code>CHANGELOG.md</code>-Datei, macht Releases und setzt die korrekte Versionsnummer z.B. im <code>package.json</code>. Release-Please arbeitet in zwei Schritten: Zuerst erstellt resp. aktualisiert die Action nach jedem Merge in den Hauptbranch einen sogenannten Release-PR. Wenn dieser PR dann gemergt wird, erstellt die Action einen Release-Tag und bildet daraus den Release selbst. Um einen sauberen Ablauf und \u00fcbersichtliche Release Notes zu gew\u00e4hrleisten, ist das Beachten der oben erw\u00e4hnten Commit-Regeln in den PR Titeln zwingend notwendig.  Kurz vor dem Release m\u00fcssen die Discussions- und Issue-Templates, die eine Versionsauswahl anbieten (aktuell Bug in Issues und Test in Discussions), entsprechend der Version im Release-PR angepasst werden. Danach kann der Release erstellt werden.</p>"},{"location":"git/#release-erstellen","title":"Release erstellen","text":"<p>Sobald wir f\u00fcr einen neuen Release bereit sind, wird der Release PR durchgesehen (Review) und daraufhin zusammengef\u00fchrt (merge). Dadurch wird automatisch der entsrpechende Release publiziert und das Produkt innert k\u00fcrzester Zeit bereitgestellt. Der Download wird dem Release angeh\u00e4ngt.</p>"},{"location":"tests/","title":"Tests","text":"<p> \u00a0 Das beschriebene Vorgehen zu den Testcases ist ein erster Entwurf. Details und Strukturen k\u00f6nnen jederzeit ge\u00e4ndert oder angepasst werden.</p> <p>Neben den Unit- und e2e-Tests sind wir auch auf standardisierte Tests von Seiten der User angewiesen.</p> <p>Die einzelnen Testcases werden im Repository-spezifischen Wiki aufgelistet.</p>"},{"location":"tests/#testcase-beschreibung-im-wiki","title":"Testcase-Beschreibung im Wiki","text":"<p>Der Titel der einzelnen Wiki-Seite sollte lediglich \"T nn\" (bspw. T 01) beinhaltet. Dies hilft uns, um einfach auf die einzelnen Testcases verlinken zu k\u00f6nnen. In Issues, wie auch in den Discussions reicht das Schreiben von <code>T-01</code> und der Link zum ersten Testcase wird automatisch gesetzt (\u00e4hnlich wie bspw. <code>#42</code>, um auf ein Issue, eine Discussion oder einen Pull Request zu verweisen). Leider funktionieren diese automatischen Verlinkungen nicht im Wiki selbst. Die andere Problematik ist, dass im Titel kein \"-\" geschrieben werden kann, resp. wird dieser beim Speichern automatisch entfernt, ist aber bei der automatischen Verlinkung sehr wichtig!</p> <p>Die Seite wird (wie bei Issues und Discussions) in Markdown geschrieben.</p> <pre><code># [Name des Testcases]\n\n## Beschreibung\n&lt;!-- kurze Beschreibung --&gt;\n\n## Erwartetes Ergebnis\n\n1. Jeder Punkt\n1. als Liste\n1. auff\u00fchren\n\n## Verweise auf Discussions\n\n[#145](https://github.com/av-dimag/ech-0160-dimag-ingest/discussions/145)\n\n## Verweise auf Issues\n\n[#171](https://github.com/av-dimag/ech-0160-dimag-ingest/issues/171)\n\n## Testergebnis (bei Erfolg)\n&lt;!-- evt. Screenshot hier einf\u00fcgen --&gt;\n\n## Protokollierung\n\nDie Protokollierung erfolgt \u00fcber das \n[Discussion-Formular \"Test Report\"](https://github.com/av-dimag/ech-0160-dimag-ingest/discussions/new?category=test-report).\n</code></pre>"},{"location":"tests/#ablauf-der-tests","title":"Ablauf der Tests","text":"<p>Gem\u00e4ss Beschreibung vorgehen und das erwartete Ergebnis \u00fcberpr\u00fcfen.</p> <p>Im Repository https://github.com/av-dimag/ech-0160-testdaten befinden sich Test-SIPs (geordnet nach eCH-0160 Version), die verwendet werden k\u00f6nnen. Es empfiehlt sich aber, dass mit eigenen, richtigen Daten getestet wird, um Unvorgesehenes besser abzufangen und sp\u00e4ter korrigieren zu k\u00f6nnen.</p>"},{"location":"tests/#protokollierung-in-den-discussions","title":"Protokollierung in den Discussions","text":"<p>Die Tests werden innerhalb der Discussion in der Kategorie \"Test Report\" protokolliert. Dazu steht ein vorgefertigtes Formular zur Verf\u00fcgung, das innerhalb erw\u00e4hnter Kategorie \u00fcber den Button \"New Discussion\" oder \u00fcber folgenden Link ge\u00f6ffnet werden kann: https://github.com/av-dimag/ech-0160-dimag-ingest/discussions/new?category=test-report.</p>"}]}